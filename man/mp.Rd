% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mp.R
\name{mp}
\alias{mp}
\alias{print.mpnmf}
\alias{mp_programs}
\alias{mp_identity}
\alias{mp_scores}
\alias{mp_signatures}
\alias{mp_samples}
\alias{mp_coverage}
\title{Identify meta programs.}
\usage{
mp(
  nmf_outs,
  cor = "pearson",
  signed = TRUE,
  threshold = NULL,
  repr = "tree",
  cluster = NULL,
  dynamic = FALSE,
  ...,
  ids = NULL
)

\method{print}{mpnmf}(x, s_min = 1/3, ...)

mp_programs(x, s_min = 1/3)

mp_identity(x, s_min = 1/3, flatten = FALSE)

mp_scores(x, s_min = 1/3)

mp_signatures(x, s_min = 1/3, n_signatures = 20L)

mp_samples(x, s_min = 1/3)

mp_coverage(x, s_min = 1/3)
}
\arguments{
\item{nmf_outs}{A list of NMF results for each sample,
\link[NMF:types]{hasBasis} and \link[NMF:types]{hasCoef} must return \code{TRUE}.}

\item{cor}{A character string indicating which correlation coefficient (or
covariance) is to be computed. One of "pearson" (default), "kendall", or
"spearman": can be abbreviated. Details see \link{cor}.}

\item{signed}{A boolean value indicates whether to use signed similarity. If
\code{FALSE}, correlation coefficients will be transformed by \code{abs(s)}. If \code{TRUE},
correlation coefficients will be transformed by \code{(1 + s) / 2}.}

\item{threshold}{Program-program similarity were filtered out (set to \code{0}) if
their connections were smaller (or equal) than \code{threshold}. Default: \code{0.5}
for signed network, and \code{0.3} for unsigned network.}

\item{repr}{A character string of "tree" or "graph" indicates the structure
representation of Program-program similarity matrix.}

\item{cluster}{A character string or function indicating how to clustering
the program-program similarity matrix. Default: if repr is \code{"tree"},
cluster will be \code{"ward.D2"}, if repr is \code{"graph"}, cluster will be
\code{"infomap"}.}

\item{dynamic}{A boolean value indicates whether to use
\link[dynamicTreeCut:cutreeDynamic]{cutreeDynamic} to define the tree groups.
Only be used when repr is "tree".}

\item{...}{Additional arguments passed to \link[stats:cutree]{cutree} or
\link[dynamicTreeCut:cutreeDynamic]{cutreeDynamic} or \verb{igraph::cluster_*}
function (when \code{cluster} was passed as a function, ...  will not be used).}

\item{ids}{Sample identifiers, must be the same length of nmf_factors.}

\item{x}{A \code{mpnmf} object.}

\item{s_min}{A scalar integer indicates the minimal number of samples or a
scalar numeric (\verb{0 < s_min < 1}) indicates the minimal proportion of samples
to define the meta program. If \code{NULL}, no filters will be applied. Default:
\code{1/3}.}

\item{flatten}{A boolean value indicates whether to return an atomic
characters instead of a list.}

\item{n_signatures}{A scalar integer to specify the number of features to
define the program signature.}
}
\value{
\code{mp}: A list of class \code{mpnmf} object with following elements:
\itemize{
\item \code{mp_programs}: A list of meta programs.
\item \code{mp_samples}: A list of samples define the meta programs.
\item \code{mp_scores}: A list of meta program scores, which were defined as the mean
NMF factor basis across the component programs.
}

In addition, following attributes are attached with this object
\itemize{
\item \code{similarity}: similarity matrix.
\item \code{stats}: A list of statistics for tree or graph object
\item \code{identity}: A list of character indicates which program the cells were
allocated.
}

\code{mp_signatures}: A list of features to define the meta program signature.

\code{mp_samples}: A list of samples indicates where the meta program is from.

\code{mp_coverage}: A numeric indicates the fraction of samples the meta program
was detected.

\code{mp_identity}: A list or an atomic character indicates  which program the
cells were allocated.
}
\description{
Identify meta programs.
}
\details{
If \code{repr} is \code{tree}, \link[stats:hclust]{hclust} will be used to define the tree
structrue, then \link[stats:cutree]{cutree} or
\link[dynamicTreeCut:cutreeDynamic]{cutreeDynamic} will be used to cut the tree
into groups, in this way, \code{cluster} must be a string to define hclust method
or a function accepts a \link[stats:dist]{dist} object and return a
\link[stats:hclust]{hclust} object. Otherwise, \code{cluster} must be the suffix of
any igraph community detection algorithm or a function accepts a
\link[igraph:make_graph]{graph} object and return a \link[igraph:communities]{communities}
object. For example, cluster="louvain" will use
\link[igraph:cluster_louvain]{cluster_louvain}.
}
\note{
When using a cutom function in \code{cluster}, you must follow the tree
nodes (or graph vertex) names, that means you must return the groups in the
same order of the tree nodes (or graph vertex) name. Since the internal will
restore the program names using the tree nodes (or graph vertex) name.
}
